name: Approve Security Labels

on:
  issue_comment:
    types: [created]
  pull_request_review:
    types: [submitted]


permissions:
  pull-requests: write
  issues: write
  contents: read

jobs:
  approve-label:
    runs-on: ubuntu-latest
    steps:
      - name: Check if the necessary actions have been taken to approve
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const secTeam = ["DuncanRoweWV"];

            let pr;
            let prNumber;
            
            // Event is pull_request.labeled (label added)
            if (context.payload.pull_request) {
              prNumber = context.payload.pull_request.number;
            }
            else if (context.payload.issue && context.payload.issue.pull_request) {
              prNumber = context.payload.issue.number;
              const { data } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
            pr = data;
            }

            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            
            const labels = currentLabels.map(label => label.name);

            const securityApproved = labels.includes("Security Approved");
            const hasDevSecLabel = labels.includes("A: No Security Impact") || labels.includes("B: Developer Security Review - light touch");
            const hasSecLabel = labels.includes("C: Security Team to Review");


            if(!securityApproved){
              // Gets comments
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });
  
              // Gets request reviewers
              const prDetails = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
              });
  
  
              let lgtmFound = false;
              let secFound = false;
  
              if (hasDevSecLabel) {
  
                const reviewsResponse = await github.rest.pulls.listReviews({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                });
  
  
                // Build a set of everyone who was EVER a legitimate reviewer
                const legitimateReviewers = new Set();
                
                // Add requested reviewers
                for (const user of prDetails.data.requested_reviewers) {
                  legitimateReviewers.add(user.login.toLowerCase());
                }
                
                // Add everyone who ever submitted a review (any state)
                for (const r of reviewsResponse.data) {
                  if (r.user?.login) {
                    legitimateReviewers.add(r.user.login.toLowerCase());
                  }
                }

                console.log(legitimateReviewers);
                
                lgtmFound = comments.some(comment =>
                  comment.body?.toLowerCase().includes("lgtm") &&
                  legitimateReviewers.has(comment.user?.login?.toLowerCase())
                ) ||
                reviewsResponse.data.some(review =>
                  review.body?.toLowerCase().includes("lgtm") &&
                  legitimateReviewers.has(review.user?.login?.toLowerCase())
                );
              }
                
              if(hasSecLabel){
                const secTeamLower = secTeam.map(u => u.toLowerCase());
  
                secFound = comments.some(comment => {
                  return comment.body.toLowerCase().includes("lgtm") &&
                         secTeamLower.includes(comment.user.login.toLowerCase());
                });
              }
  
              if(hasDevSecLabel && !lgtmFound) {
                  core.setFailed("❌ PR has no `LGTM` comment from a reviewer");
              }
              if(hasSecLabel && !secFound) {
                  core.setFailed("❌ PR has no `LGTM` comment found from a security team member.");
              }
              
              if(hasDevSecLabel == false && hasSecLabel == false) {
                  core.setFailed("❌ PR has no security label set.");
              }
            }
              
      - name: Add 'security label' to PR
        if: success()
        uses: actions-ecosystem/action-add-labels@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          labels: Security Approved
      - name: Remove label from PR
        uses: actions/github-script@v7
        if: success()
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              let issueNumber;

              if (context.payload.pull_request && context.payload.pull_request.number) {
                issueNumber = context.payload.pull_request.number;
              } else if (context.payload.issue && context.payload.issue.number) {
                issueNumber = context.payload.issue.number;
              } 
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                name: 'Waiting for Security Review Completion'  // label to remove
              });
              console.log("Label removed successfully");
            } catch (error) {
              if (error.status === 404) {
                console.log("Label not found, nothing to remove");
              } else {
                throw error;
              }
            }
      
